# Whether the player is an AI or not. Works in more situations but it is more intrusive.
method IsAIAccurate(player) //by deltin
{
    define originalHero = HeroOf(player);

    // originalHero will equal null if no hero is chosen. 
    if (originalHero == null)
        return false;

    // The hero being forced should be any hero that isn't an AI option.
    ForcePlayerHero(player,         Hero.Ashe);
    define isAI = HeroOf(player) != Hero.Ashe;

    ForcePlayerHero(player, originalHero);
    StopForcingHero(player);

    return isAI;
}

# Whether the player is an AI or not. Works in less situations but much less intrusive. Requires the player to be spawned in
method IsAIUnintrusive(player)
{
	Communicate(player, Communication.VoiceLineUp);
	return Not(IsCommunicating(player, Communication.VoiceLineUp));
}

# Whether the player is looking directly at the sphere. Has collision.
method SphereHitbox(player, spherePosition, sphereRadius)
{
	return DistanceBetween(spherePosition, EyeCastPosition(player, DistanceBetween(EyePosition(player), spherePosition))) <= sphereRadius;
}

# Simplified RayCastHitPosition that casts a ray in the direction the player is looking.
method EyeCastPosition(player, range)
{
	return RayCastHitPosition(EyePosition(player), EyePosition(player) + FacingDirection(player) * range);
}

# Total value of an array
method SumOfArray(arrayToSum)
{
	define total = 0;
	foreach (define value in arrayToSum)
	{
		total += arrayToSum[value];
	}
	return total;
}

# Average value of an array
method AverageOfArray(arrayToAverage)
{
	return SumOfArray(arrayToAverage) / CountOf(arrayToAverage);
}

# Returns distance as if both points were on the same y level.
method HorizontalDistance(point1, point2)
{
	return Sqrt((XOf(point1) - XOf(point2)) ^ 2 + (ZOf(point1) - ZOf(point2)) ^ 2);
}

# 1/2 as the fraction will give the midpoint between the points and 1/10 will return the point one tenth of the way along a straight line drawn between them. Fraction should be fraction of distance along straight line between points and must be less than 1 and greater than 0.
method LinearInterpolate(point1, point2, fraction)
{
	return point1*(1-fraction) + point2*fraction;
}

# Same as LinearInterpolate, but instead of going a fraction of the distance between points it goes a distance between points.
method LinearInterpolateDistance(point1, point2, distance)
{
	return LinearInterpolate(point1, point1, distance / DistanceBetween(point1, point2));
}

# Convert from meters per second to kilometers per hour
method ToKPH(metersPerSecond) { return metersPerSecond * 3.6; }

//convert to americanese units
# Convert from meters per second to miles per hour
method ToMPH(metersPerSecond) { return metersPerSecond * 2.237; }
# Convert from meters to feet
method ToFt(meters) { return meters * 2.381; }
# Convert from meters to yards
method ToYards(meters) { return meters * 1.094; }
# Convert from meters to inches
method ToInches(meters) { return meters * 39.37; }

# Height of player measured from eyes to feet.
method TallnessOfPlayer(player)
{
	return YOf(EyePosition(player)) - YOf(PositionOf(player));
}

# Checks if a point is visible on screen to the player.
method IsOnScreen(player, point, fovOfPlayer)
{
	return (
		IsInLineOfSight(EyePosition(player), point) &
		IsInViewAngle(player, point, fovOfPlayer / 2)
	);
}

# Sets the health of the player.
method SetHealth(player, health)
{
	if (Health(player) < health) {
		Heal(player, Null(), health - Health(player));
	} else if (Health(player) > health) {
		Damage(player, Null(), Health(player) - health);
	}
}

# Imperfect way of getting position of nearest solid surface. Accuracy is amount of times looped.
method NearestSolidSurface(point, accuracy)
{
	define directions = [Up(), Down(), Forward(), Right(), Backward(), Left()];
	for (define i = 0; i < accuracy; i++)
	{
		directions = SortedArray(directions, DistanceBetween(point, RayCastHitPosition(point, point + (ArrayElement() * 10000))));
		directions = [directions, Midpoint(directions[0], directions[1])];
	}
	directions = SortedArray(directions, DistanceBetween(point, RayCastHitPosition(point, point + (ArrayElement() * 10000))));
	return RayCastHitPosition(point, point + (directions[0] * 10000));
}

# Get median of array that is pre-sorted.
method SortedMedian(sortedArray)
{
	return BlendedIndex(sortedArray, (CountOf(sortedArray) + 1) / 2);
}

# Get median of unsorted array.
method UnsortedMedian(unsortedArray)
{
	return SortedMedian(SortedArray(unsortedArray, ArrayElement()));
}

# Highest value of array subtracted from lowest value of array
method Range(inputArray)
{
	return MaxOfArray(inputArray) - MinOfArray(inputArray);
}

# Gets height of hero measured from eyes to feet
method TallnessOfHero(hero)
{
	return
		(hero == Hero.Dva) ? 1.74
		: ((hero == Hero.Orisa) ? 1.78
		: ((hero == Hero.Reinhardt) ? 1.8
		: ((hero == Hero.Roadhog | hero == Hero.Zarya) ? 1.6
		: ((hero == Hero.Winston | hero == Hero.Doomfist | hero == Hero.Widowmaker) ? 1.5
		: ((hero == Hero.WreckingBall) ? 1.83
		: ((hero == Hero.Ashe | hero == Hero.Mercy) ? 1.45
		: ((hero == Hero.Bastion) ? 1.82
		: ((hero == Hero.Genji) ? 1.2
		: ((hero == Hero.Hanzo | hero == Hero.Pharah | hero == Hero.Baptiste) ? 1.35
		: ((hero == Hero.Junkrat | hero == Hero.Tracer | hero == Hero.Ana) ? 1.25
		: ((hero == Hero.Mccree) ? 1.43
		: ((hero == Hero.Mei | hero == Hero.Sombra | hero == Hero.Symmetra) ? 1.3
		: ((hero == Hero.Reaper | hero == Hero.Soldier76 | hero == Hero.Zenyatta) ? 1.55
		: ((hero == Hero.Torbjorn) ? 1
		: ((hero == Hero.Brigitte) ? 1.58
		: ((hero == Hero.Lucio) ? 1.17
		: ((hero == Hero.Moira) ? 1.7 : Null()
		)))))))))))))))))
	;
}

# Generates an array of a length where each value is equal to its index. Great for using for Filtered and Sorted arrays.
method GenerateForeachArray(length)
{
	define returnArray;
	for (define i = 0; i < length; i++)
	{
		returnArray[i] = i;
	}
	return returnArray;
}

// # Allows you to get the index of an array as a non-integer. Blends the index lower and the index higher together in a weighted way. Array must be of multiplicable values (not player or string).
// method BlendedIndex(array, index)
// {
// 	return RoundToInteger(index, Rounding.Down) == index ?
// 		index :
// 		array[RoundToInteger(index, Rounding.Down)] * (index - RoundToInteger(index, Rounding.Down)) + array[RoundToInteger(index, Rounding.Up)] * (RoundToInteger(index, Rounding.Up) - index)
// 	;
// }

// struct RadialHeroMenu
// {
// 	define player;
// 	define heroes;
// 	define position;
// 	define radius;
	
// 	public method Open()
// 	{
// 		this.position = EyePosition(this.player) + (DirectionFromAngles(HorizontalFacingAngleOf(this.player), Min(40, Max(-40, VerticalFacingAngleOf(this.player)))) * 2);
//     	this.radius = 0;
//     	ChaseVariable(this.radius, 0.2 + (0.028 * CountOf(this.heroes)), 3);
// 	}

// 	public method Close()
// 	{
// 		ChaseVariable(this.radius, 0, 3);
// 	}

// 	public method Select()
// 	{
// 		return 
// 	}
// }