# Whether the player is an AI or not. Works in more situations but it is more intrusive.
method IsAIAccurate(player) //by deltin
{
    define originalHero = HeroOf(player);

    // originalHero will equal null if no hero is chosen. 
    if (originalHero == null)
        return false;

    // The hero being forced should be any hero that isn't an AI option.
    ForcePlayerHero(player,         Hero.Ashe);
    define isAI = HeroOf(player) != Hero.Ashe;

    ForcePlayerHero(player, originalHero);
    StopForcingHero(player);

    return isAI;
}

# Whether the player is an AI or not. Works in less situations but much less intrusive. Requires the player to be spawned in
method IsAIUnintrusive(player)
{
	Communicate(player, Communication.VoiceLineUp);
	return Not(IsCommunicating(player, Communication.VoiceLineUp));
}

# Returns an approximation of pi.
method Pi()
{
    return 355 / 113;
}

# Whether the player is looking directly at the sphere. Has collision.
method SphereHitbox(player, spherePosition, sphereRadius)
{
	return DistanceBetween(spherePosition, EyeCastPosition(player, DistanceBetween(EyePosition(player), spherePosition))) <= sphereRadius;
}

# Simplified RayCastHitPosition that casts a ray in the direction the player is looking.
method EyeCastPosition(player, range)
{
	return RayCastHitPosition(EyePosition(player), EyePosition(player) + FacingDirection(player) * range);
}

# Midpoint between 2 vectors.
method Midpoint(point1, point2)
{
	return (point1 + point2) / 2;
}

# Total value of an array
method SumOfArray(arrayToSum)
{
	define total = 0;
	foreach (define value in arrayToSum)
	{
		total += arrayToSum[value];
	}
	return total;
}

# Average value of an array
method AverageOfArray(arrayToAverage)
{
	return SumOfArray(arrayToAverage) / CountOf(arrayToAverage);
}

# Angle of field of view a certain sphere will take up at a distance. When calculating distance using a player use Eye Position.
method FOVTakenUpBySphere(distanceToSphereCenter, sphereRadius)
{
	return 2 * ArcsineToDegrees(sphereRadius / distanceToSphere);
}

# Returns distance as if both points were on the same y level.
method HorizontalDistance(point1, point2)
{
	return Sqrt((XOf(point1) - XOf(point2)) ^ 2 + (ZOf(point1) - ZOf(point2)) ^ 2);
}

# 1/2 as the fraction will give the midpoint between the points and 1/10 will return the point one tenth of the way along a straight line drawn between them. Fraction should be fraction of distance along straight line between points and must be less than 1 and greater than 0.
method LinearInterpolate(point1, point2, fraction)
{
	return point1*(1-fraction) + point2*fraction;
}

# Same as LinearInterpolate, but instead of going a fraction of the distance between points it goes a distance between points.
method LinearInterpolateDistance(point1, point2, distance)
{
	return LinearInterpolate(point1, point1, distance / DistanceBetween(point1, point2));
}

# Returns length of hypotenuse.
method Pythag(side1, side2)
{
	return Sqrt(side1^2 + side2^2);
}

# Returns length of missing side.
method PythagConverse(side1, hypotenuse)
{
	return Sqrt(hypotenuse^2 - side1^2);
}

# Convert from meters per second to kilometers per hour
method ToKPH(metersPerSecond) { return metersPerSecond * 3.6; }

//convert to americanese units
# Convert from meters per second to miles per hour
method ToMPH(metersPerSecond) { return metersPerSecond * 2.237; }
# Convert from meters to feet
method ToFt(meters) { return meters * 2.381; }
# Convert from meters to yards
method ToYards(meters) { return meters * 1.094; }
# Convert from meters to inches
method ToInches(meters) { return meters * 39.37; }

# Height of player measured from eyes to feet.
method TallnessOfPlayer(player)
{
	return YOf(EyePosition(player)) - YOf(PositionOf(player));
}

# Checks if a point is visible on screen to the player.
method IsOnScreen(player, point, fovOfPlayer)
{
	return (
		IsInLineOfSight(EyePosition(player), point) &
		IsInViewAngle(player, point, fovOfPlayer / 2)
	);
}

# Sets the health of the player.
method SetHealth(player, health)
{
	if (Health(player) < health) {
		Heal(player, Null(), health - Health(player));
	} else if (Health(player) > health) {
		Damage(player, Null(), Health(player) - health);
	}
}

# Gets max health of player. e.g. If player is Tracer it will return 150.
method GetMaxHealth(player)
{
	return Health(player) / (HealthPercent(player) / 100);
}

# Returns point calculated from starting point going in a direction for a distance.
method PointFromPointDirectionDistance(startingPoint, direction, distance)
{
	return startingPoint + (direction * distance);
}

# Imperfect way of getting position of nearest solid surface. Accuracy is amount of times looped.
method NearestSolidSurface(point, accuracy)
{
	define directions = [Up(), Down(), Forward(), Right(), Backward(), Left()];
	for (define i = 0; i < accuracy; i++)
	{
		directions = SortedArray(directions, DistanceBetween(point, RayCastHitPosition(point, point + (ArrayElement() * 10000))));
		directions = [directions, Midpoint(directions[0], directions[1])];
	}
	directions = SortedArray(directions, DistanceBetween(point, RayCastHitPosition(point, point + (ArrayElement() * 10000))));
	return RayCastHitPosition(point, point + (directions[0] * 10000));
}

# Get median of array that is pre-sorted.
method SortedMedian(sortedArray)
{
	return CountOf(sortedArray) % 2 == 0 ?
		(sortedArray[(CountOf(sortedArray) + 1) / 2 - 0.5] + sortedArray[(CountOf(sortedArray) + 1) / 2 + 0.5]) / 2 :
		sortedArray[(CountOf(sortedArray) + 1) / 2];
}

# Get median of unsorted array.
method UnsortedMedian(unsortedArray)
{
	return SortedMedian(SortedArray(unsortedArray, ArrayElement()));
}

# Highest value of array
method MaxOfArray(inputArray)
{
	return LastOf(SortedArray(inputArray, ArrayElement()));
}

# Lowest value of array
method MinOfArray(inputArray)
{
	return SortedArray(inputArray, ArrayElement())[0];
}

# Highest value of array subtracted from lowest value of array
method Range(inputArray)
{
	return MaxOfArray(inputArray) - MinOfArray(inputArray);
}

# Gets height of hero measured from eyes to feet
method TallnessOfHero(hero)
{
	return
		(hero == Hero.Dva) ? 1.74
		: ((hero == Hero.Orisa) ? 1.78
		: ((hero == Hero.Reinhardt) ? 1.8
		: ((hero == Hero.Roadhog | hero == Hero.Zarya) ? 1.6
		: ((hero == Hero.Winston | hero == Hero.Doomfist | hero == Hero.Widowmaker) ? 1.5
		: ((hero == Hero.WreckingBall) ? 1.83
		: ((hero == Hero.Ashe | hero == Hero.Mercy) ? 1.45
		: ((hero == Hero.Bastion) ? 1.82
		: ((hero == Hero.Genji) ? 1.2
		: ((hero == Hero.Hanzo | hero == Hero.Pharah | hero == Hero.Baptiste) ? 1.35
		: ((hero == Hero.Junkrat | hero == Hero.Tracer | hero == Hero.Ana) ? 1.25
		: ((hero == Hero.Mccree) ? 1.43
		: ((hero == Hero.Mei | hero == Hero.Sombra | hero == Hero.Symmetra) ? 1.3
		: ((hero == Hero.Reaper | hero == Hero.Soldier76 | hero == Hero.Zenyatta) ? 1.55
		: ((hero == Hero.Torbjorn) ? 1
		: ((hero == Hero.Brigitte) ? 1.58
		: ((hero == Hero.Lucio) ? 1.17
		: ((hero == Hero.Moira) ? 1.7 : Null()
		)))))))))))))))))
	;
}

# Generates an array of a length where each value is equal to its index. Great for using for Filtered and Sorted arrays.
method GenerateForeachArray(length)
{
	define returnArray;
	for (define i = 0; i < length; i++)
	{
		returnArray[i] = i;
	}
	return returnArray;
}
