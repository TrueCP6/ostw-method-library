# Total value of an array
method SumOfArray(arrayToSum)
{
	define total = 0;
	foreach (define value in arrayToSum)
	{
		total += arrayToSum[value];
	}
	return total;
}

# Average value of an array
method AverageOfArray(arrayToAverage)
{
	return SumOfArray(arrayToAverage) / CountOf(arrayToAverage);
}

# Imperfect way of getting position of nearest solid surface. Accuracy is amount of times looped.
method NearestSolidSurface(point, accuracy)
{
	define directions = [Up(), Down(), Forward(), Right(), Backward(), Left()];
	for (define i = 0; i < accuracy; i++)
	{
		directions = SortedArray(directions, DistanceBetween(point, RayCastHitPosition(point, point + (ArrayElement() * 10000))));
		directions = [directions, Midpoint(directions[0], directions[1])];
	}
	directions = SortedArray(directions, DistanceBetween(point, RayCastHitPosition(point, point + (ArrayElement() * 10000))));
	return RayCastHitPosition(point, point + (directions[0] * 10000));
}

# Gets height of hero measured from eyes to feet
method TallnessOfHero(hero)
{
	return
		(hero == Hero.Dva) ? 1.74
		: ((hero == Hero.Orisa) ? 1.78
		: ((hero == Hero.Reinhardt) ? 1.8
		: ((hero == Hero.Roadhog | hero == Hero.Zarya) ? 1.6
		: ((hero == Hero.Winston | hero == Hero.Doomfist | hero == Hero.Widowmaker) ? 1.5
		: ((hero == Hero.WreckingBall) ? 1.83
		: ((hero == Hero.Ashe | hero == Hero.Mercy) ? 1.45
		: ((hero == Hero.Bastion) ? 1.82
		: ((hero == Hero.Genji) ? 1.2
		: ((hero == Hero.Hanzo | hero == Hero.Pharah | hero == Hero.Baptiste) ? 1.35
		: ((hero == Hero.Junkrat | hero == Hero.Tracer | hero == Hero.Ana) ? 1.25
		: ((hero == Hero.Mccree) ? 1.43
		: ((hero == Hero.Mei | hero == Hero.Sombra | hero == Hero.Symmetra) ? 1.3
		: ((hero == Hero.Reaper | hero == Hero.Soldier76 | hero == Hero.Zenyatta) ? 1.55
		: ((hero == Hero.Torbjorn) ? 1
		: ((hero == Hero.Brigitte) ? 1.58
		: ((hero == Hero.Lucio) ? 1.17
		: ((hero == Hero.Moira) ? 1.7 : Null()
		)))))))))))))))))
	;
}

# Generates an array of a length where each value is equal to its index. Great for using for Filtered and Sorted arrays.
method GenerateForeachArray(length)
{
	define returnArray;
	for (define i = 0; i < length; i++)
	{
		returnArray[i] = i;
	}
	return returnArray;
}

struct Dictionary 
{
	define Keys;
	define Values;
	public Dictionary(keys, values)
	{
		Keys = keys;
		Values = values;
	}

	public method Dictionary()
	{
		Keys = EmptyArray();
		Values = EmptyArray();
	}

	public method Dictionary(tupleArray)
	{
		for (define i = 0; i < CountOf(tupleArray); i++)
		{
			Keys[i] = tupleArray[i][0];
			Values[i] = tupleArray[i][1];
		}
	}

	public method GetValueFromKey(key)
	{
		return Values[IndexOfArrayValue(Keys, key)];
	}

	public method GetKeyFromValue(value)
	{
		return this.Keys[IndexOfArrayValue(Values, value)];
	}

	public method SetValueAtKey(key, value)
	{
		Values[IndexOfArrayValue(Keys, key)] = value;
	}

	public method SetKeyAtValue(value, key)
	{
		Keys[IndexOfArrayValue(Values, value)] = key;
	}

	public method RemoveLeftPlayers()
	{
		for (define i = 0; 0 < CountOf(Keys); i++)
		{
			if (EntityExists(Keys[i]) == false)
			{
				RemoveFromArrayAtIndex(Keys, i);
				RemoveFromArrayAtIndex(Values, i);
				i--;
			}
		}
	}

	public method AddEntry(key, value)
	{
		Keys = [Keys, key];
		Values = [Values, value];
	}

	public method RemoveEmptyEntries()
	{
		for (define i = 0; i < CountOf(Keys); i++)
		{
			if (Keys[i] == Null() | Values[i] == Null())
			{
				RemoveFromArrayAtIndex(Keys, i);
				RemoveFromArrayAtIndex(Values, i);
				i--;
			}
		}
	}

	public method RemoveEntryByKey(key)
	{
		Values = RemoveFromArray(Values, this.GetValueFromKey(key));
		Keys = RemoveFromArray(Keys, key);
	}

	public method RemoveEntryByValue(value)
	{
		Keys = RemoveFromArray(Keys, this.GetKeyFromValue(value));
		Values = RemoveFromArray(Values, value);
	}

	public method GetTupleArray()
	{
		define array;
		for (define i = 0; i < CountOf(Keys); i++)
			array[i] = [Keys[i], Values[i]];
		return array;
	}
}

struct Trigger
{
	define IsActive;

	public Trigger() 
	{
		IsActive = False();
	}

	public method Activate()
	{
		IsActive = True();
	}

	public method Deactivate()
	{
		IsActive = False();
	}
}

struct SphericalBarrier
{
	define Position;
	define Radius;

	public SphericalBarrier(position, radius)
	{
		Position = position;
		Radius = radius;
	}

	public method IsPlayerInside(player)
	{
		return DistanceBetween(PositionOf(player), Position) <= Radius;
	}

	public method IsPlayerOutside(player)
	{
		return DistanceBetween(PositionOf(player), Position) > Radius;
	}

	public method TeleportPlayerInside(player)
	{
		Teleport(player, Destination(PositionOf(player), DirectionTowards(PositionOf(player), Position), DistanceBetween(PositionOf(player), Position) - Radius));
	}

	public method TeleportPlayerOutside(player)
	{
		Teleport(player, Destination(PositionOf(player), DirectionTowards(Position, PositionOf(player)), Radius - DistanceBetween(PositionOf(player), Position)));
	}

	public method BoopPlayerInside(player, speed)
	{
		while (IsPlayerOutside(player))
			ApplyImpulse(player, DirectionTowards(PositionOf(player), Position), speed, Relative.ToWorld, ContraryMotion.Cancel);
	}

	public method BoopPlayerOutside(player, speed)
	{
		while (IsPlayerInside(player))
			ApplyImpulse(player, DirectionTowards(Position, PositionOf(player)), speed, Relative.ToWorld, ContraryMotion.Cancel);
	}

	public method PlayersOutside()
	{
		return FilteredArray(AllPlayers(), DistanceBetween(PositionOf(ArrayElement()), Position) > Radius);
	}

	public method PlayersInside()
	{
		return FilteredArray(AllPlayers(), DistanceBetween(PositionOf(ArrayElement()), Position) <= Radius);
	}
}