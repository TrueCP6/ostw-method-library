method IsAIAccurate(player) //by deltin
{
    define originalHero = HeroOf(player);

    // originalHero will equal null if no hero is chosen. 
    if (originalHero == null)
        return false;

    // The hero being forced should be any hero that isn't an AI option.
    ForcePlayerHero(player,         Hero.Ashe);
    define isAI = HeroOf(player) != Hero.Ashe;

    ForcePlayerHero(player, originalHero);
    StopForcingHero(player);

    return isAI;
}

//requires player to be spawned in
method IsAIUnintrusive(player)
{
	Communicate(player, Communication.VoiceLineUp);
	return Not(IsCommunicating(player, Communication.VoiceLineUp));
}

method Pi()
{
    return 355 / 113;
}

method SphereHitbox(player, spherePosition, sphereRadius)
{
	return DistanceBetween(spherePosition, EyeCastPosition(player, DistanceBetween(EyePosition(player), spherePosition))) <= sphereRadius;
}

method EyeCastPosition(player, range)
{
	return RayCastHitPosition(EyePosition(player), EyePosition(player) + FacingDirection(player) * range);
}

method Midpoint(point1, point2)
{
	return (point1 + point2) / 2;
}

method SumOfArray(arrayToSum)
{
	define total = 0;
	foreach (define value in arrayToSum)
	{
		total += arrayToSum[value];
	}
	return total;
}

method AverageOfArray(arrayToAverage)
{
	return SumOfArray(arrayToAverage) / CountOf(arrayToAverage);
}

//returns angle a sphere will take up in field of view
method FOVTakenUpBySphere(distanceToSphereCenter, sphereRadius)
{
	return 2 * ArcsineToDegrees(sphereRadius / distanceToSphere);
}

//returns distance as if both points were on the same y level
method HorizontalDistance(point1, point2)
{
	return Sqrt((XOf(point1) - XOf(point2)) ^ 2 + (ZOf(point1) - ZOf(point2)) ^ 2);
}

//fraction should be fraction of distance along straight line between points e.g 1/2 will give the midpoint between the points and 1/10 will return the point one tenth of the way along a straight line drawn between them
method LinearInterpolate(point1, point2, fraction)
{
	return point1*(1-fraction) + point2*fraction;
}

//same as linear interpolate, but instead returns a point a certain distance along a straight line drawn between the 2 points 
method LinearInterpolateDistance(point1, point2, distance)
{
	return LinearInterpolate(point1, point1, distance / DistanceBetween(point1, point2));
}

//returns hypotenuse length
method Pythag(side1, side2)
{
	return Sqrt(side1^2 + side2^2);
}

//returns side2 length
method Pythag(side1, hypotenuse)
{
	return Sqrt(hypotenuse^2 - side1^2);
}

method ToKPH(metersPerSecond) { return metersPerSecond * 3.6; }

//convert to americanese units
method ToMPH(metersPerSecond) { return metersPerSecond * 2.237; }
method ToFt(meters) { return meters * 2.381; }
method ToYards(meters) { return meters * 1.094; }
method ToInches(meters) { return meters * 39.37; }

method TallnessOfPlayer(player)
{
	return YOf(EyePosition(player)) - YOf(PositionOf(player));
}

method IsOnScreen(player, point, fovOfPlayer)
{
	return (
		IsInLineOfSight(EyePosition(player), point) &
		IsInViewAngle(player, point, fovOfPlayer / 2)
	);
}

method SetHealth(player, health)
{
	if (Health(player) < health) {
		Heal(player, Null(), health - Health(player));
	} else if (Health(player) > health) {
		Damage(player, Null(), Health(player) - health);
	}
}

method GetMaxHealth(player)
{
	return Health(player) / (HealthPercent(player) / 100);
}

method PointFromPointDirectionDistance(startingPoint, direction, distance)
{
	return startingPoint + (direction * distance);
}

method NearestSolidSurface(point, accuracy)
{
	define directions = [Up(), Down(), Forward(), Right(), Backward(), Left()];
	for (define i = 0; i < accuracy; i++)
	{
		directions = SortedArray(directions, DistanceBetween(point, RayCastHitPosition(point, point + (ArrayElement() * 10000))));
		directions = [directions, Midpoint(directions[0], directions[1])];
		directions = SortedArray(directions, DistanceBetween(point, RayCastHitPosition(point, point + (ArrayElement() * 10000))));
	}
	return RayCastHitPosition(point, point + (directions[0] * 10000));
}

method SortedMedian(sortedArray)
{
	return CountOf(sortedArray) % 2 == 0 ?
		(sortedArray[(CountOf(sortedArray) + 1) / 2 - 0.5] + sortedArray[(CountOf(sortedArray) + 1) / 2 + 0.5]) / 2 :
		sortedArray[(CountOf(sortedArray) + 1) / 2];
}

method UnsortedMedian(unsortedArray)
{
	return SortedMedian(SortedArray(unsortedArray, ArrayElement()));
}

method MaxOfArray(inputArray)
{
	return LastOf(SortedArray(inputArray, ArrayElement()));
}

method MinOfArray(inputArray)
{
	return SortedArray(inputArray, ArrayElement())[0];
}

method Range(inputArray)
{
	return MaxOfArray(inputArray) - MinOfArray(inputArray);
}

method TallnessOfHero(hero)
{
	return
		hero == Hero.Dva ? 1.74
		: (hero == Hero.Orisa ? 1.78
		: (hero == Hero.Reinhardt ? 1.8
		: (hero == Hero.Roadhog | hero == Hero.Zarya ? 1.6
		: (hero == Hero.Winston | hero == Hero.Doomfist | hero == Hero.Widowmaker ? 1.5
		: (hero == Hero.WreckingBall ? 1.83
		: (hero == Hero.Ashe | hero == Hero.Mercy ? 1.45
		: (hero == Hero.Bastion ? 1.82
		: (hero == Hero.Genji ? 1.2
		: (hero == Hero.Hanzo | hero == Hero.Pharah | hero == Hero.Baptiste ? 1.35
		: (hero == Hero.Junkrat | hero == Hero.Tracer | hero == Hero.Ana ? 1.25
		: (hero == Hero.Mccree ? 1.43
		: (hero == Hero.Mei | hero == Hero.Sombra | hero == Hero.Symmetra? 1.3
		: (hero == Hero.Reaper | hero == Hero.Soldier76 | hero == Hero.Zenyatta? 1.55
		: (hero == Hero.Torbjorn ? 1
		: (hero == Hero.Brigitte ? 1.58
		: (hero == Hero.Lucio ? 1.17
		: (hero == Hero.Moira ? 1.7 : Null()
		)))))))))))))))))
	;
}
