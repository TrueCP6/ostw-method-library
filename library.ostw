# Total value of an array
method SumOfArray(arrayToSum)
{
	define total = 0;
	foreach (define value in arrayToSum)
	{
		total += arrayToSum[value];
	}
	return total;
}

# Average value of an array
method AverageOfArray(arrayToAverage)
{
	return SumOfArray(arrayToAverage) / CountOf(arrayToAverage);
}

# Imperfect way of getting position of nearest solid surface. Accuracy is amount of times looped.
method NearestSolidSurface(point, accuracy)
{
	define directions = [Up(), Down(), Forward(), Right(), Backward(), Left()];
	for (define i = 0; i < accuracy; i++)
	{
		directions = SortedArray(directions, DistanceBetween(point, RayCastHitPosition(point, point + (ArrayElement() * 10000))));
		directions = [directions, Midpoint(directions[0], directions[1])];
	}
	directions = SortedArray(directions, DistanceBetween(point, RayCastHitPosition(point, point + (ArrayElement() * 10000))));
	return RayCastHitPosition(point, point + (directions[0] * 10000));
}

# Gets height of hero measured from eyes to feet
method TallnessOfHero(hero)
{
	return
		(hero == Hero.Dva) ? 1.74
		: ((hero == Hero.Orisa) ? 1.78
		: ((hero == Hero.Reinhardt) ? 1.8
		: ((hero == Hero.Roadhog | hero == Hero.Zarya) ? 1.6
		: ((hero == Hero.Winston | hero == Hero.Doomfist | hero == Hero.Widowmaker) ? 1.5
		: ((hero == Hero.WreckingBall) ? 1.83
		: ((hero == Hero.Ashe | hero == Hero.Mercy) ? 1.45
		: ((hero == Hero.Bastion) ? 1.82
		: ((hero == Hero.Genji) ? 1.2
		: ((hero == Hero.Hanzo | hero == Hero.Pharah | hero == Hero.Baptiste) ? 1.35
		: ((hero == Hero.Junkrat | hero == Hero.Tracer | hero == Hero.Ana) ? 1.25
		: ((hero == Hero.Mccree) ? 1.43
		: ((hero == Hero.Mei | hero == Hero.Sombra | hero == Hero.Symmetra) ? 1.3
		: ((hero == Hero.Reaper | hero == Hero.Soldier76 | hero == Hero.Zenyatta) ? 1.55
		: ((hero == Hero.Torbjorn) ? 1
		: ((hero == Hero.Brigitte) ? 1.58
		: ((hero == Hero.Lucio) ? 1.17
		: ((hero == Hero.Moira) ? 1.7 : Null()
		)))))))))))))))))
	;
}

# Generates an array of a length where each value is equal to its index. Great for using for Filtered and Sorted arrays.
method GenerateForeachArray(length)
{
	define returnArray;
	for (define i = 0; i < length; i++)
	{
		returnArray[i] = i;
	}
	return returnArray;
}

struct Dictionary 
{
	define Keys;
	define Values;
	public Dictionary(keys, values)
	{
		Keys = keys;
		Values = values;
	}

	public method GetValueFromKey(key)
	{
		return this.Values[IndexOfArrayValue(this.Keys, key)];
	}

	public method GetKeyFromValue(value)
	{
		return this.Keys[IndexOfArrayValue(this.Values, value)];
	}
}

// struct RadialHeroMenu
// {
// 	define player;
// 	define heroes;
// 	define position;
// 	define radius;
	
// 	public method Open()
// 	{
// 		this.position = EyePosition(this.player) + (DirectionFromAngles(HorizontalFacingAngleOf(this.player), Min(40, Max(-40, VerticalFacingAngleOf(this.player)))) * 2);
//     	this.radius = 0;
//     	ChaseVariable(this.radius, 0.2 + (0.028 * CountOf(this.heroes)), 3);
// 	}

// 	public method Close()
// 	{
// 		ChaseVariable(this.radius, 0, 3);
// 	}

// 	public method Select()
// 	{
// 		return 
// 	}
// }